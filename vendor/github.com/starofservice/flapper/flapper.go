// flapper package allows to serialize complex custom structures to a flat map of strings and deserialize it back.
package flapper

import (
  "fmt"
  "reflect"
  "strings"
  "strconv"
)

const (
  DefaultDelimiter = "."
  DefaultPrefix = ""
)

// Marshal returns a flat map of strings for the provided object.
// It travers the object recursively. Map item key is a complex structure which is built
// from the object keys, sleated by dots (by default). The map item value is 
// a corresponding object field value converted to a string.
func Marshal(object interface{}) (map[string]string, error) {
  f, err := New(DefaultPrefix, DefaultDelimiter)
  if err != nil {
    return nil, err
  }

  m, err := f.Marshal(object)
  if err != nil {
    return nil, err
  }

  return m, nil
}

// Unmarshal restores object from the map generated by Marshal
func Unmarshal(data map[string]string, object interface{}) error {
  f, err := New(DefaultPrefix, DefaultDelimiter)
  if err != nil {
    return err
  }

  err = f.Unmarshal(data, object)
  if err != nil {
    return err
  }

  return nil
}

// Flapper struct is used for extended configuration of Marshal and Unmarshal methods.
// It allows to set custom delimiter and prefix.
// When you need this kind of customizaiton, you must use Marshal and Unmarshal methods 
// of the Flapper item instead of simple Marshal and Unmarshal functions described above.
type Flapper struct {
  Delimiter string
  Prefix string
}

// Returns a new *Flapper
func New(prefix, delimiter string) (*Flapper, error) {
  if len(delimiter) == 0 {
    err := fmt.Errorf("Delimiter can't be empty")
    return nil, err
  }
  return &Flapper{
    Delimiter: delimiter,
    Prefix: prefix,
  }, nil
}

// Behaves in a same way as a Marshal function, but uses
// a custom configuration defined at the Flapper object.
func (self *Flapper) Marshal(object interface{}) (map[string]string, error) {
  resp := make(map[string]string)
  resp, err := self.marshStruct(resp, reflect.ValueOf(object), self.Prefix)
  if err != nil {
    return nil, fmt.Errorf("Unable to serialize provided object due to the error: %s", err.Error())
  }
  return resp, nil
}

func (self *Flapper) marshStruct(resp map[string]string, object reflect.Value, prefix string) (map[string]string, error) {
  var err error
  for _, f := range structFields(object) {
    name := f.Name

    prefixedName := name
    if len(prefix) > 0 {
      prefixedName = prefix + self.Delimiter + name
    }

    field := object.FieldByName(name)

    resp, err = self.marshField(resp, field, prefixedName)
    if err != nil {
      return nil, err
    }
  }
  return resp, nil
}


func (self *Flapper) marshField(resp map[string]string, field reflect.Value, prefix string) (map[string]string, error) {
  var err error
  switch field.Kind() {

  case reflect.Bool:
    resp[prefix] = strconv.FormatBool(field.Bool())

  case reflect.Float32:
    resp[prefix] = strconv.FormatFloat(field.Float(), 'E', -1, 32)

  case reflect.Float64:
    resp[prefix] = strconv.FormatFloat(field.Float(), 'E', -1, 64)

  case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
    resp[prefix] = strconv.FormatInt(field.Int(), 10)

  case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
    resp[prefix] = strconv.FormatUint(field.Uint(), 10)

  case reflect.String:
    resp[prefix] = field.String()

  case reflect.Slice, reflect.Array:
    for i := 0; i < field.Len(); i++ {
      prefixIndexed := prefix + self.Delimiter + strconv.Itoa(i)
      resp, err = self.marshField(resp, field.Index(i), prefixIndexed)
      if err != nil {
        return nil, err
      }
    }

  //// It isn't enough. Keys may have different types, thus we have to serealize them too.
  // case reflect.Map:
  //   for i := 0; i < field.MapKeys.Len(); i++ {
  //     prefixedName = prefixedName + self.Delimiter + field.MapKeys.Index(i).String()
  //     newField := field.MapIndex(field.MapKeys.Index(i))
  //     resp, err := self.marshComplexField(resp, newField, prefixedName)
  //     if err != nil {
  //       return nil, err
  //     }
  //   }

  case reflect.Struct:
    resp, err = self.marshStruct(resp, field, prefix)
    if err != nil {
      return nil, err
    }

  default:
    return nil, fmt.Errorf("Field '%s' has unsuppoerted type: %s", prefix, field.Kind())
  }

  return resp, nil
}

// Behaves in a same way as a Unmarshal function, but uses
// a custom configuration defined at the Flapper object.
func (self *Flapper) Unmarshal(data map[string]string, object interface{}) error {
  po := reflect.ValueOf(object).Elem()
  err := self.unmarshStruct(data, po, self.Prefix)
  if err != nil {
    return fmt.Errorf("Unable to deserialize provided object due to the error: %s", err.Error())
  }

  return nil
}

func (self *Flapper) unmarshStruct(data map[string]string, object reflect.Value, prefix string) error {
  for _, f := range structFields(object) {
    name := f.Name

    prefixedName := name
    if len(prefix) > 0 {
      prefixedName = prefix + self.Delimiter + name
    }

    field := object.FieldByName(name)

    err := self.unmarshField(data, field, prefixedName)
    if err != nil {
      return err
    }
  }
  return nil
}

func (self *Flapper) unmarshField(data map[string]string, field reflect.Value, prefix string) error {
  switch field.Kind() {

  case reflect.Bool:
    value := data[prefix]
    d, err := strconv.ParseBool(value)
    if err != nil {
      return fmt.Errorf("Failed to parse 'bool' value '%s' for field '%s' due to the error: %s", value, prefix, err.Error())
    }
    field.SetBool(d)

  case reflect.Float32:
    value := data[prefix]
    d, err := strconv.ParseFloat(value, 32)
    if err != nil {
      return fmt.Errorf("Failed to parse 'float32' value '%s' for field '%s' due to the error: %s", value, prefix, err.Error())
    }
    field.SetFloat(d)

  case reflect.Float64:
    value := data[prefix]
    d, err := strconv.ParseFloat(value, 64)
    if err != nil {
      return fmt.Errorf("Failed to parse 'float64' value '%s' for field '%s' due to the error: %s", value, prefix, err.Error())
    }
    field.SetFloat(d)

  case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
    value := data[prefix]
    d, err := strconv.ParseInt(value, 10, 64)
    if err != nil {
      return fmt.Errorf("Failed to parse 'Int64' value '%s' for field '%s' due to the error: %s", value, prefix, err.Error())
    }
    field.SetInt(d)

  case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
    value := data[prefix]
    d, err := strconv.ParseUint(value, 10, 64)
    if err != nil {
      return fmt.Errorf("Failed to parse 'Uint64' value '%s' for field '%s' due to the error: %s", value, prefix, err.Error())
    }
    field.SetUint(d)

  case reflect.String:
    field.SetString(data[prefix])

  case reflect.Array:
    var arrLen int
    prefixIndexed := prefix + self.Delimiter
    for k, _ := range data {
      if strings.HasPrefix(k, prefixIndexed) {
        arrLen++
      }
    }
    if arrLen > field.Len() {
      arrLen = field.Len()
    }
    for i := 0; i < arrLen; i++ {
      err := self.unmarshField(data, field.Index(i), prefixIndexed + strconv.Itoa(i))
      if err != nil {
        return err
      }
    }

  case reflect.Slice:
    var arrLen int
    prefixIndexed := prefix + self.Delimiter
    for k, _ := range data {
      if strings.HasPrefix(k, prefixIndexed) {
        arrLen++
      }
    }
    newData := reflect.MakeSlice(field.Type(), arrLen, arrLen)
    for i := 0; i < arrLen; i++ {
      err := self.unmarshField(data, newData.Index(i), prefixIndexed + strconv.Itoa(i))
      if err != nil {
        return err
      }
    }
    field.Set(newData)

  //// It isn't enough. Keys may have different types, thus we have to serealize them too.
  // case reflect.Map:
  //   prefixedName = prefixedName + self.Delimiter
  //   for k, _ := range data {
  //     if string.HasPrefix(k, prefixedName) {
  //       rest := string([]byte(k)[len(prefixedName):])
  //       itemKey := strings.SplitN(rest, self.Delimiter, 2)[0]
  //       err := self.unmarshStruct(data, field.MapIndex(itemKey), prefixedName + itemKey)
  //       if err != nil {
  //         return err
  //       }
  //     }
  //   }

  case reflect.Struct:
    err := self.unmarshStruct(data, field, prefix)
    if err != nil {
      return err
    }

  default:
    return fmt.Errorf("Field '%s' has unsuppoerted type: %s", prefix, field.Kind())
  }

  return nil
}

func structFields(obj reflect.Value) []reflect.StructField {
  t := obj.Type()

  var f []reflect.StructField
  
  for i := 0; i < t.NumField(); i++ {
    field := t.Field(i)
    // we can't access the value of unexported fields
    if field.PkgPath != "" {
      continue
    }

    // // don't check if it's omitted
    // if tag := field.Tag.Get(s.TagName); tag == "-" {
    //   continue
    // }

    f = append(f, field)
  }

  return f
}